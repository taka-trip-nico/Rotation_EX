--track0:‰ñ“]Ž²1,-360,360,0,0.1
--track1:‰ñ“]Ž²2,-360,360,0,0.1
--track2:‰ñ“]Ž²3,-360,360,0,0.1
--dialog:‰ñ“]Ž²1,axis[1]="x";‰ñ“]Ž²2,axis[2]="y";‰ñ“]Ž²3,axis[3]="z";

debug_print(axis[2])

--ŽlŽÌŒÜ“üBx:’lAy:ŠÛ‚ß•B
function fix(x, y)
    x = math.floor(x * y + 0.5) / y
    return x
end

-- 3x3s—ñ‚ÌÏBa:¶Ab:‰EB
function cross(a, b)
    local c = {}
    for i = 1, 3 do
        c[i] = {}
        for j = 1, 3 do
            c[i][j] = a[i][1] * b[1][j] + a[i][2] * b[2][j] + a[i][3] * b[3][j]
        end
    end
    return c
end

-- ‰ñ“]s—ñ‚Ì‘ã“üBaxis:Ž²(string)
function make_matrix(ax,n)
    local m = {}
    if ax == "x" then
        m[1] = {1, 0, 0}
        m[2] = {0, math.cos(r[n]), -math.sin(r[n])}
        m[3] = {0, math.sin(r[n]), math.cos(r[n])}
    elseif ax == "y" then
        m[1] = {math.cos(r[n]), 0, math.sin(r[n])}
        m[2] = {0, 1, 0}
        m[3] = {-math.sin(r[n]), 0, math.cos(r[n])}
    elseif ax == "z" then
        m[1] = {math.cos(r[n]), -math.sin(r[n]), 0}
        m[2] = {math.sin(r[n]), math.cos(r[n]), 0}
        m[3] = {0, 0, 1}
    end
    return m
end

r={}
r[1] = obj.track0 * math.pi / 180
r[2] = obj.track1 * math.pi / 180
r[3] = obj.track2 * math.pi / 180
m1 = make_matrix(axis[3],3)
m2 = make_matrix(axis[2],2)
m3 = make_matrix(axis[1],1)
mr = {}
mr = cross(cross(m1, m2), m3)

obj.ry = math.asin(mr[1][3])

debug_print(string.format("math.cos(obj.ry)=%f", math.cos(obj.ry)))
if fix(math.cos(obj.ry), 10 ^ 10) == 0 then
    obj.rz = 0
    sx = mr[2][1]
    cx = mr[2][2]

    sx = fix(sx, 10 ^ 10)
    cx = fix(cx, 10 ^ 10)

    if sx > 0 then
        if cx >= 0 then
            obj.rx = math.acos(cx)
        elseif cx < 0 then
            obj.rx = math.acos(cx)
        end
    elseif sx < 0 then
        if cx >= 0 then
            obj.rx = math.asin(sx)
        elseif cx < 0 then
            obj.rx = 2 * math.pi - math.acos(cx)
        end
    elseif sx == 0 then
        if cx > 0 then
            obj.rx = 0
        elseif cx < 0 then
            obj.rx = math.pi
        end
    end
else
    sx = -1*mr[2][3] / math.cos(obj.ry)
    cx = mr[3][3] / math.cos(obj.ry)

    sx = fix(sx, 10 ^ 10)
    cx = fix(cx, 10 ^ 10)

    debug_print(string.format("sx=%+2.10f", sx))
    debug_print(string.format("cx=%+2.10f", cx))

    if sx > 0 then
        obj.rx = math.acos(cx)
    elseif sx < 0 then
        if cx >= 0 then
            obj.rx = math.asin(sx)
        elseif cx < 0 then
            obj.rx = 2 * math.pi - math.acos(cx)
        end
    elseif sx == 0 then
        if cx > 0 then
            obj.rx = 0
        elseif cx < 0 then
            obj.rx = math.pi
        end
    end

    sz = -1*mr[1][2] / math.cos(obj.ry)
    cz = mr[1][1] / math.cos(obj.ry)

    sz = fix(sz, 10 ^ 10)
    cz = fix(cz, 10 ^ 10)

    debug_print(string.format("sz=%+2.20f", sz))
    debug_print(string.format("cz=%+2.10f", cz))
    if sz > 0 then
        obj.rz = math.acos(cz)
    elseif sz < 0 then
        if cz >= 0 then
            obj.rz = math.asin(sz)
        elseif cz < 0 then
            obj.rz = 2 * math.pi - math.acos(cz)
        end
    elseif sz == 0 then
        if cz > 0 then
            obj.rz = 0
        elseif cz < 0 then
            obj.rz = math.pi
        end
    end
end
debug_print(string.format("obj.rx=%f", obj.rx))
debug_print(string.format("obj.ry=%f", obj.ry))
debug_print(string.format("obj.rz=%f", obj.rz))
obj.rx = obj.rx * 180 / math.pi
obj.ry = obj.ry * 180 / math.pi
obj.rz = obj.rz * 180 / math.pi
debug_print(string.format("obj.rx=%f", obj.rx))
debug_print(string.format("obj.ry=%f", obj.ry))
debug_print(string.format("obj.rz=%f", obj.rz))
